<!DOCTYPE html>
<html lang="en">
<head>
 <title>Frederik Braun: Finding and Fixing DOM-based XSS with Static Analysis</title>
 <meta charset="utf-8" />
 <meta name="viewport" content="width=device-width, initial-scale=1">
 <link rel="stylesheet" href="/theme/css/main.css" type="text/css" />
 <link rel="icon" href='data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" version="1.1" viewBox="0 0 100 200"><style>svg{background-color:%231f54a6;}text{fill:white;font-family:Georgia,Cambria,"Times New Roman",Times,serif;}</style><text y="1.2em" font-size="135">F</text></svg>'>
 <link href="https://vaurenw.github.io/feeds/all.atom.xml" type="application/atom+xml" rel="alternate" title="Frederik Braun ATOM Feed" />
 <link href="https://vaurenw.github.io/feeds/all.rss.xml" type="application/rss+xml" rel="alternate" title="Frederik Braun RSS Feed" />
 <meta property="og:site_name" content="Frederik Braun"/>
 <meta property="og:type" content="website"/>
 <meta name="twitter:card" content="summary"/>
 <meta name="description" content="Finding and Fixing DOM-based XSS with Static Analysis" />
 <meta property="og:title" content="Finding and Fixing DOM-based XSS with Static Analysis"/>
 <meta property="og:url" content="https://vaurenw.github.io/finding-and-fixing-dom-based-xss-with-static-analysis.html"/>
 <meta name="twitter:title" content="Finding and Fixing DOM-based XSS with Static Analysis" />
 <meta name="fediverse:author" content="@freddy@security.plumbing" />
 <link rel="canonical" href="https://vaurenw.github.io/finding-and-fixing-dom-based-xss-with-static-analysis.html"/>
</head>

<body>
<header class="site-header" role="banner">
<div class="wrapper"><a class="site-title" rel="author" href="/">Frederik Braun</a><nav class="site-nav">
  <input type="checkbox" id="nav-trigger" class="nav-trigger">
  <label for="nav-trigger">
  <span class="menu-icon">
    <svg viewBox="0 0 18 15" width="18px" height="15px">
      <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"></path>
    </svg>
  </span>
  </label>
  <div class="trigger">
    <a class="page-link" href="https://vaurenw.github.io/archives.html">Blog</a>
    <a class="page-link" href="https://vaurenw.github.io/pages/publications.html">Portfolio</a>
    <a class="page-link" href="https://vaurenw.github.io/contact.html">Contact</a>
</div>
</nav></div>
</header>

<hr class="tophr">
<div id='wrapper' class="wrapper">
<div id='text1'>
        
<header>
  <h1>Finding and Fixing DOM-based XSS with Static Analysis</h1>
  <time datetime="2023-01-02T00:00:00+01:00">Mon 02 January 2023</time>
</header>
<article>
    <p><em>This article first appeared on the <a href="https://blog.mozilla.org/attack-and-defense/2021/11/03/finding-and-fixing-dom-based-xss-with-static-analysis/">Firefox Attack &amp; Defense blog</a>.</em></p>
<p>Despite <a href="https://www.w3.org/TR/CSP1/">all</a> <a href="https://www.w3.org/TR/CSP2/">the</a> <a href="https://www.w3.org/TR/CSP3/">efforts</a> of fixing Cross-Site Scripting (XSS) on the web, it continuously ranks as one of the <a href="https://cwe.mitre.org/top25/archive/2021/2021_cwe_top25.html">most dangerous security issues in software</a>.</p>
<p>In particular, DOM-based XSS is gaining increasing relevance: DOM-based XSS is a form of XSS where the vulnerability resides completely in the client-side code (e.g., in JavaScript). Indeed, more and more web applications implement all of their UI code using frontend web technologies: Single Page Applications (SPAs) are more prone to this vulnerability, mainly because they are more JavaScript-heavy than other web applications. An XSS in Electron applications, however, has the potential to cause <em>even more</em> danger due to the system-level APIs available in the Electron framework (e.g., reading local files and executing programs).</p>
<p>The following article will take a deeper look into Mozilla's static analysis approach for defeating DOM-based XSS. This is one part of <a href="https://blog.mozilla.org/attack-and-defense/2020/07/07/hardening-firefox-against-injection-attacks-the-technical-details/">our mitigations against injection attacks in the Firefox browser</a>, for which the user interface is also written in HTML, JavaScript and CSS.</p>
<h1>Background: Real world example of DOM-based XSS</h1>
<p>Let's take a moment to look at typical sources of DOM-based XSS first. Imagine a bit of JavaScript (JS) code like here:</p>
<div class="highlight"><pre><span></span><code><span class="kd">let</span><span class="w"> </span><span class="nx">html</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="sb">`</span>
<span class="sb">&lt;div class=&quot;image-box&quot;&gt;</span>
<span class="sb">&lt;img class=&quot;image&quot;</span>
<span class="sb">src=&quot;</span><span class="si">${</span><span class="nx">imageUrl</span><span class="si">}</span><span class="sb">&quot;/&gt;</span>
<span class="sb">&lt;/div&gt;`</span><span class="p">;</span>
<span class="c1">// (...)</span>
<span class="nx">main</span><span class="p">.</span><span class="nx">innerHTML</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">html</span><span class="p">;</span>
</code></pre></div>

<p>You first will notice the variable called <code>html</code>, which constructs a bit of HTML using a Javascript <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Template_literals">template string</a>. It also features an inclusion of another variable - <code>imageUrl</code> - to be used in the <code>src</code> attribute. The full html string is then assigned to <code>main.innerHTML</code>.</p>
<p>If we assume that the <code>imageUrl</code> variable is controlled by an attacker - then they might easily break out of the <code>src</code> attribute syntax and enter arbitrary HTML of their choosing to launch an XSS attack.</p>
<p>This example demonstrates how easy it is to accidentally implement a DOM-XSS vulnerability: The application was expecting an image URL, but also accepts all sorts of strings, which are then parsed into HTML and JavaScripts. This is enough to enable XSS attacks.</p>
<p>If we want to avoid these bugs we need to find all instances in which the application parses a string into HTML and then determine if it can be controlled from the outside (e.g., form input, URL parameters, etc).</p>
<p>To do so efficiently, we are required to inspect various patterns in source code. First, let's look at all assignments to <code>innerHTML</code> or <code>outerHTML</code>. In order not to miss other sources of XSS, we also need to inspect calls to the following functions: <code>insertAdjacentHTML()</code>, <code>document.write()</code>, <code>document.writeln()</code>.</p>
<p>When first trying this ourselves, we at Mozilla used text search with tools like <code>grep</code> or <code>ripgrep</code>, but it did not turn out successful: Even a complicated search pattern gave us thousands of results and contained many false positives (e.g., assignments of safe, hardcoded strings). We knew we needed something that is more syntax-aware.</p>
<h1>Linting and Static Analysis</h1>
<p>Static Analysis is just another way to say that we want to inspect source code automatically. Our static analysis method builds on existing JavaScript linting with <a href="https://eslint.org">eslint</a>, which supports robust JS source code parsing and also supports new JavaScript syntax extensions. Furthermore, the provided plugin API helps us build an automated check with relatively little new code. However, there are some limitations:</p>
<h2>Caveats</h2>
<p>Since we are scanning the JavaScript <em>source code</em>, there are some things we can <em>not</em> easily do:</p>
<ul>
<li>Static Analysis has almost no visibility into a variable's content (i.e., harmful, harmless, attacker controlled, hardcoded).</li>
<li>In JavaScript, the source code does not tell us a variable's type (e.g., Number, String, Array, Object)</li>
<li>Static Analysis is easily fooled by minification, bundling or obfuscation.</li>
</ul>
<p>At Mozilla, we managed to accept these limitations because we can build on our existing engineering practices:</p>
<ul>
<li>All proposed patches are going through code review.</li>
<li>The repository contains all relevant JavaScript source code (e.g., third-party libraries are vendored in).</li>
</ul>
<p>The latter point is sometimes hard to guarantee and requires using dependencies through published and versioned libraries. Third-party JavaScript dependencies through <code>&lt;script&gt;</code> elements are therefore out of scope. For a cohesive security posture, the associated security risks need to be mitigated by other means (e.g., using in-browser checks at runtime like CSP). You should validate whether the following assumptions also hold true for your project.</p>
<h2>How Static Analysis works</h2>
<p>To explain the implementation of our eslint plugin, let's take a look at how JavaScript can be parsed and understood by eslint: A common representation is the so-called Abstract Syntax Tree (AST). Let's take a look at the AST for a simplified version of our vulnerability from above:</p>
<p><code>foo.innerHTML = evil</code>:</p>
<div class="highlight"><pre><span></span><code>AssignmentExpression (operator: =)
|-- left: MemberExpression
| |-- object: Identifier &quot;foo&quot;
| `-- property: Identifier &quot;innerHTML&quot;
`-- right
`-- Identifier &quot;evil&quot;
</code></pre></div>

<p>Indeed, the whole line is seen as an assignment, with a left and a right side. The right side is a variable (Identifier) and the left side <code>foo.innerHTML</code> is accessing the property of an object (MemberExpression).</p>
<p>Now let's look at the AST representation for a case, where XSS is not possible, which just assigns an empty string: <code>foo.innerHTML = ""</code>.</p>
<div class="highlight"><pre><span></span><code>AssignmentExpression (operator: =)
|-- left: MemberExpression
| |-- object: Identifier &quot;foo&quot;
| `-- property: Identifier &quot;innerHTML&quot;
`-- right
`-- Literal &quot;&quot;
</code></pre></div>

<p>Did you spot the difference? Again the assignment has a left and right side. But in this case, the right node is of type <em>Literal</em> (i.e., a hardcoded string).</p>
<p>We can use exactly these kinds of differences to understand the basics of our linter plugin: When looking at assignments, all hardcoded strings are considered trustworthy and do not need further static analysis. But only if all patches are subject to code review, before being committed to the source code. Naturally, the plugin has many more syntax expressions to take into account.</p>
<p>While bearing in mind, that the abstract syntax tree can <em>not</em> tell us anything about a variable despite its name, we probably want to allow some other things: In our case, we configured our linter runtime (not the plugin itself) to skip files if they are in the <code>test/</code> folder, as we do not expect test code to be running on our users' systems.</p>
<p>We also need to take false positives into account. False positives are incorrect detections of code, in which the content of the variable is known to be safe through other means. Here, we recommend our developers to use a trusted Sanitizer library that will always return XSS-safe HTML. Essentially, we allow all code on the right side of the assignment as long as it is wrapped in a function call to a known sanitizer like so:</p>
<div class="highlight"><pre><span></span><code><span class="nx">foo</span><span class="p">.</span><span class="nx">innerHTML</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="nx">DOMPurify</span><span class="p">.</span><span class="nx">purify</span><span class="p">(</span><span class="nx">evil</span><span class="p">);</span>
</code></pre></div>

<p>We currently recommend using <a href="https://github.com/cure53/DOMPurify/">DOMPurify</a> as your sanitizer and our linter allows such calls in our default configuration. In parallel, we are also actively working on specifying and implementing a secure <a href="https://wicg.github.io/sanitizer-api/">Sanitizer API</a> for the web platform. Either way, as long as our sanitizer function is well implemented, the input data doesn't have to be.</p>
<p>With all these techniques and decisions in mind, we ended up developing an eslint plugin called <a href="https://github.com/mozilla/eslint-plugin-no-unsanitized"><strong>eslint-plugin-no-unsanitized</strong></a>, which also contains checks for other typical XSS-related source code fragments like <code>document.write()</code> and is fully configurable in terms of which sanitizers you want to allow.</p>
<h1>Evaluation &amp; Integration</h1>
<p>When we first tried finding XSS in the Firefox UI automatically, we used <code>grep</code> and spotted thousands of potential vulnerabilities. With the eslint plugin, we reduced this number to 34 findings! This reduction enabled us to start a focussed manual code audit and resulted in finding only two critical security bugs. Imagine trying to identify those two bugs by going through thousands of potential findings manually.</p>
<p>Eventually, we fully integrated <a href="https://github.com/mozilla/eslint-plugin-no-unsanitized">eslint-plugin-no-unsanitized</a> into our CI systems by choosing an iterative approach:</p>
<ul>
<li>We enabled the linter over time and directory by directory.</li>
<li>We skip test files.</li>
<li>We also had to allow some exceptions for code that violates the linter but was not actually insecure (validated through code audit).</li>
</ul>
<p>An important note here is that allowing linter violations incurs a risk that needs to be temporary. It's still useful to tolerate exceptions <em>during</em> the migration to the linter plugin, but not after. We've also experienced that developers misunderstand the purpose of the linter and try to design their own path of evading these checks. Our lesson: By controlling the path for exceptions and escalations, we were able to understand and adopt the tool to find workable solutions for all developers and their use cases.</p>
<p>Once all code has been integrated, it should be on the security &amp; analysis teams to get the number of exceptions down to zero. With all those bugs fixed and most linter violations resolved, we are running the plugin against all newly submitted Firefox code and have a pretty good handle on XSS issues in our codebase.</p>
<h1>Conclusion: You can fix DOM-XSS</h1>
<p>Fixing DOM-based XSS across a whole codebase is not easy, but we believe this overview will serve as a useful guide: As a first step, we can highly recommend just using the <a href="https://github.com/mozilla/eslint-plugin-no-unsanitized">eslint plugin no-unsanitized</a> as it is and running it against your source code. A dry-run will already tell you whether the topic of DOM-based XSS is a problem at all. Our integration section showed how you can start using the linter gradually, based on risk or feasibility. But we also want to note that source code analysis is not a silver bullet: There are notable caveats and it is useful to complement static analysis with enforcement in the browser and at runtime.
But, eventually you will be able to get rid of a lot of DOM-XSS.</p>
<p><small><em>This is a summary of my presentation of the same title, delivered at Sekurak Mega Hacking Party (June 2021) and JSCamp Barcelona (July 2021) and enterJS (June 2022) Feel free to <a href="https://frederik-braun.com/contact.html">reach out</a>, if you want me to talk about web security at your event </em>.</small></p>
</article>

<hr>

<section id="minicontact">
<em>
<!-- Please comment on <a href="https://social.security.plumbing/@freddy">Mastodon</a>. -->
If you find a mistake in this article, you can <a href="https://github.com/freddyb/homepage/edit/main/content/finding_fixing_dom_xss.md">submit a pull request on GitHub</a>.
</em>
</section>

<section id="article-list">
<h4>Recent posts</h4>
<ol>
  <li><a href="https://vaurenw.github.io/madweb-keynote-2025.html">With Carrots & Sticks - Can the browser handle web security?</a>
    <em>(Tue 08 April 2025)</em>
  </li>
  <li><a href="https://vaurenw.github.io/home-assistant-can-not-be-secured-for-internet-access.html">Home assistant can not be secured for internet access</a>
    <em>(Sun 15 December 2024)</em>
  </li>
  <li><a href="https://vaurenw.github.io/modern-solutions-xsleaks.html">Modern solutions against cross-site attacks</a>
    <em>(Tue 26 November 2024)</em>
  </li>
  <li><a href="https://vaurenw.github.io/prompt-injections-and-a-demo.html">Prompt Injections and a demo</a>
    <em>(Wed 18 September 2024)</em>
  </li>
  <li><a href="https://vaurenw.github.io/mozilla-monument.html">The Mozilla Monument in San Francisco</a>
    <em>(Fri 05 July 2024)</em>
  </li>
            
</ol>
</section>
</div>
</div>
</body>
</html>